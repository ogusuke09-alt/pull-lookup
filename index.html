<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Pull # Lookup — OCR App</title>
  <style>
    body { font-family: -apple-system, sans-serif; background:#0d1117; color:#eee; text-align:center; padding:20px; }
    input, button { margin:6px; padding:8px; font-size:16px; }
    button { background:#007bff; color:#fff; border:none; border-radius:6px; }
    .ok { color:#8ef59a; font-weight:bold; }
    .err { color:#ff7b7b; font-size:14px; margin-top:6px; min-height:1.4em; }
    .result { margin-top:20px; font-size:18px; border:1px solid #333; padding:12px; border-radius:8px; }
    hr { border:0; border-top:1px solid #333; margin:18px 0; }
    .row { display:flex; gap:8px; justify-content:center; flex-wrap:wrap; }
    #editBlock { display:none; margin-top:10px; }
    #preview { max-width:95vw; border:1px dashed #555; border-radius:8px; background:#0b1117; touch-action:none; }
    .hint { color:#9aa3ab; font-size:13px; }
  </style>
</head>
<body>
  <h2>Pull # Lookup — OCR App (Multi-core + Crop)</h2>

  <p><strong>Step 1:</strong> Load OCR engine (files must be hosted in the same folder).</p>
  <button id="btnInit">Init OCR</button>
  <div id="ocrState">Waiting…</div>
  <div id="err" class="err"></div>

  <hr>

  <p><strong>Step 2:</strong> Upload your CSV or load a sample:</p>
  <input type="file" id="csvFile" accept=".csv"><br>
  <button id="btnSample">Load sample</button>
  <div id="status"></div>

  <hr>

  <p><strong>Step 3:</strong> Enter LDU or use OCR:</p>
  <div class="row">
    <input type="text" id="ldu" placeholder="Enter LDU (last 3)">
    <button id="btnSearch">Search</button>
  </div>
  <div class="row">
    <button id="btnCamera">Scan with Camera</button>
    <button id="btnImage">Choose Image</button>
  </div>

  <!-- New: simple editor with crop -->
  <div id="editBlock">
    <p class="hint">Drag on the image to draw a crop box around the postal code, then click “Run OCR on Crop”.</p>
    <canvas id="preview" width="0" height="0"></canvas><br>
    <div class="row">
      <button id="btnOCRCrop">Run OCR on Crop</button>
      <button id="btnResetCrop">Reset Crop</button>
    </div>
  </div>

  <div id="result" class="result" style="display:none"></div>

<script src="tesseract.min.js"></script>
<script>
/* =========================================================
   LDU-focused OCR helpers (PREPROCESS + TUNED SETTINGS)
   ========================================================= */

// 1) Preprocess to boost tiny/low-contrast codes
function preprocessForLDU(imgOrCanvas) {
  const getW = x => x.width || x.videoWidth || x.naturalWidth;
  const getH = x => x.height || x.videoHeight || x.naturalHeight;
  const w = getW(imgOrCanvas), h = getH(imgOrCanvas);

  // Draw source
  const base = document.createElement('canvas');
  base.width = w; base.height = h;
  base.getContext('2d', { willReadFrequently:true }).drawImage(imgOrCanvas, 0, 0, w, h);

  // Upscale 2x for more pixels
  const out = document.createElement('canvas');
  out.width = Math.max(1, Math.round(w * 2));
  out.height = Math.max(1, Math.round(h * 2));
  const ctx = out.getContext('2d', { willReadFrequently:true });
  ctx.imageSmoothingEnabled = true;
  ctx.imageSmoothingQuality = 'high';
  ctx.drawImage(base, 0, 0, out.width, out.height);

  // Grayscale + mild contrast boost
  let img = ctx.getImageData(0,0,out.width,out.height);
  let d = img.data;
  for (let i=0;i<d.length;i+=4){
    let y = 0.2126*d[i] + 0.7152*d[i+1] + 0.0722*d[i+2];
    y = (y - 128) * 1.35 + 128;               // tweak 1.2–1.6 if needed
    y = y < 0 ? 0 : y > 255 ? 255 : y;
    d[i]=d[i+1]=d[i+2]=y;
  }
  ctx.putImageData(img,0,0);

  // Simple binarize (threshold)
  img = ctx.getImageData(0,0,out.width,out.height);
  d = img.data;
  const T = 140;                                // tweak 120–160 if needed
  for (let i=0;i<d.length;i+=4){
    const v = d[i] < T ? 0 : 255;
    d[i]=d[i+1]=d[i+2]=v;
  }
  ctx.putImageData(img,0,0);

  // Light “bolden” (3×3 dilation) to close gaps
  const pad = ctx.getImageData(0,0,out.width,out.height);
  const p = pad.data;
  for (let y=1;y<out.height-1;y++){
    for (let x=1;x<out.width-1;x++){
      let black=false;
      for (let dy=-1; dy<=1 && !black; dy++){
        const row=(y+dy)*out.width;
        for (let dx=-1; dx<=1; dx++){
          if (p[(row + (x+dx))*4] === 0) { black = true; break; }
        }
      }
      const i4=(y*out.width + x)*4;
      const v = black ? 0 : 255;
      p[i4]=p[i4+1]=p[i4+2]=v;
    }
  }
  ctx.putImageData(pad,0,0);

  return out; // canvas ready for OCR
}

// 2) Tesseract config tuned for a single 3-char LDU
const OCR_OPTS = {
  tessedit_pageseg_mode: '8', // SINGLE_WORD (try '7' if line; '6' if block)
  tessedit_char_whitelist: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789',
  user_defined_dpi: '300',
  preserve_interword_spaces: '1'
};

// 3) Fix common confusions & enforce Letter–Digit–Letter
function normalizeLDU(txt) {
  if (!txt) return '';
  let t = txt.replace(/[^A-Za-z0-9]/g,'').toUpperCase();

  const swaps = { '0':'O','1':'I','5':'S','2':'Z','8':'B' };
  t = t.split('').map(ch => swaps[ch] ?? ch).join('');

  if (t.length >= 3) {
    let a=t[0], b=t[1], c=t[2];
    if (!/[A-Z]/.test(a)) a='O';
    if (!/[0-9]/.test(b)) b='1';
    if (!/[A-Z]/.test(c)) c='O';
    return (a+b+c).slice(0,3);
  }
  return t;
}

// 4) One-call OCR for LDU (uses preprocess + config)
async function runLDUOCR(imgOrCanvas, worker) {
  const pre = preprocessForLDU(imgOrCanvas);
  const { data } = await worker.recognize(pre, { lang:'eng', config: OCR_OPTS });
  return normalizeLDU(data.text);
}

/* =========================================================
   ORIGINAL APP CODE (with crop editor added)
   ========================================================= */

let data=[], worker=null;

// ========== INIT OCR ==========
async function initOCR(){
  try {
    document.getElementById('err').textContent="";
    document.getElementById('ocrState').textContent="Loading Tesseract…";

    worker = await Tesseract.createWorker("eng", 1, {
      workerPath: "worker.min.js",
      corePath: "core/"   // <── directory with 4 core files
    });

    // Strong defaults for Canadian postal codes
    await worker.setParameters({
      tessedit_pageseg_mode: 8,  // SINGLE_WORD (best when you crop or zoom)
      tessedit_char_whitelist: 'ABCEGHJKLMNPRSTVWXYZ0123456789',
      preserve_interword_spaces: '1',
      user_defined_dpi: '300'
    });

    document.getElementById('ocrState').innerHTML = "<span class='ok'>OCR ready ✅</span>";
  } catch(e){
    document.getElementById('err').textContent = "Init failed: "+e.message;
    document.getElementById('ocrState').textContent="Error ❌";
  }
}
document.getElementById('btnInit').addEventListener('click', initOCR);

// ========== CSV LOAD ==========
document.getElementById('csvFile').addEventListener('change', e=>{
  const f=e.target.files[0]; if(!f) return;
  const r=new FileReader();
  r.onload=ev=>{
    const lines = ev.target.result.split(/\r?\n/);
    const headers = lines[0].split(",");
    const depot = headers.indexOf("Depot");
    const route = headers.indexOf("Route");
    const street= headers.indexOf("Street");
    const range = headers.indexOf("Address Range");
    const ldu   = headers.indexOf("LDU");
    const pull  = headers.indexOf("Pull #");
    data = lines.slice(1).map(row=>{
      const c=row.split(",");
      return {Depot:c[depot], Route:c[route], Street:c[street], Range:c[range], LDU:(c[ldu]||"").trim().toUpperCase(), Pull:c[pull]};
    }).filter(x=>x.Depot && x.LDU && x.Pull);
    document.getElementById('status').textContent="CSV loaded ("+data.length+" rows)";
  };
  r.readAsText(f);
});
document.getElementById('btnSample').addEventListener('click', ()=>{
  data=[{Depot:"Whiterock",Route:"LC0008",Street:"16 Ave",Range:"1500-1598",LDU:"1C2",Pull:"7"}];
  document.getElementById('status').textContent="Sample loaded. Try LDU 1C2.";
});

// ========== SEARCH ==========
document.getElementById('btnSearch').addEventListener('click', ()=>{
  const ldu=document.getElementById('ldu').value.trim().toUpperCase();
  const hit=data.find(r=>r.LDU===ldu);
  if(hit){ showResult(hit); } 
  else { const box=document.getElementById('result'); box.style.display="block"; box.textContent="No match."; }
});
function showResult(r){
  const box=document.getElementById('result'); box.style.display="block";
  box.innerHTML=`${r.Route} • ${r.Street} ${r.Range||''}<br>LDU ${r.LDU}<br><strong>Pull # ${r.Pull}</strong>`;
}

/* ========== SIMPLE CROP EDITOR ========== */
const editBlock = document.getElementById('editBlock');
const canvas = document.getElementById('preview');
const ctx = canvas.getContext('2d', { willReadFrequently:true });
let imgBitmap = null;
let crop = { x:0, y:0, w:0, h:0, active:false };

function openEditorFromFile(file){
  const url = URL.createObjectURL(file);
  const img = new Image();
  img.onload = async () => {
    imgBitmap = await createImageBitmap(img);
    fitCanvas();
    drawPreview();
    editBlock.style.display='block';
    URL.revokeObjectURL(url);
  };
  img.onerror = () => { URL.revokeObjectURL(url); document.getElementById('err').textContent="Could not load image."; };
  img.src = url;
}

function fitCanvas(){
  if(!imgBitmap) return;
  const maxW = Math.min(900, Math.floor(window.innerWidth*0.95));
  const scale = Math.min(1, maxW / imgBitmap.width);
  canvas.width  = Math.max(1, Math.round(imgBitmap.width  * scale));
  canvas.height = Math.max(1, Math.round(imgBitmap.height * scale));
  crop = { x:0, y:0, w:0, h:0, active:false };
}

function drawPreview(){
  if(!imgBitmap) return;
  ctx.drawImage(imgBitmap, 0, 0, canvas.width, canvas.height);

  if (crop.w && crop.h){
    // darken outside
    ctx.save();
    ctx.fillStyle = "rgba(0,0,0,0.45)";
    ctx.fillRect(0,0,canvas.width,canvas.height);
    ctx.clearRect(crop.x, crop.y, crop.w, crop.h);
    ctx.restore();
    // outline
    ctx.strokeStyle = "#2f81f7";
    ctx.lineWidth = 2;
    ctx.strokeRect(crop.x, crop.y, crop.w, crop.h);
  }
}

function getPoint(ev){
  const r = canvas.getBoundingClientRect();
  const x = (ev.touches?ev.touches[0].clientX:ev.clientX) - r.left;
  const y = (ev.touches?ev.touches[0].clientY:ev.clientY) - r.top;
  return { x: Math.max(0, Math.min(canvas.width, x)),
           y: Math.max(0, Math.min(canvas.height, y)) };
}

canvas.addEventListener('mousedown', e=>{ crop.active=true; const p=getPoint(e); crop.x=p.x; crop.y=p.y; crop.w=0; crop.h=0; drawPreview(); });
canvas.addEventListener('mousemove', e=>{ if(!crop.active) return; const p=getPoint(e); crop.w=p.x-crop.x; crop.h=p.y-crop.y; drawPreview(); });
canvas.addEventListener('mouseup',   ()=>{ crop.active=false; });
canvas.addEventListener('mouseleave',()=>{ crop.active=false; });

canvas.addEventListener('touchstart', e=>{ crop.active=true; const p=getPoint(e); crop.x=p.x; crop.y=p.y; crop.w=0; crop.h=0; drawPreview(); }, {passive:false});
canvas.addEventListener('touchmove',  e=>{ if(!crop.active) return; const p=getPoint(e); crop.w=p.x-crop.x; crop.h=p.y-crop.y; drawPreview(); }, {passive:false});
canvas.addEventListener('touchend',   ()=>{ crop.active=false; }, {passive:false});

document.getElementById('btnResetCrop').addEventListener('click', ()=>{
  crop = { x:0, y:0, w:0, h:0, active:false };
  drawPreview();
});

document.getElementById('btnOCRCrop').addEventListener('click', async ()=>{
  if(!worker){ document.getElementById('err').textContent="Init OCR first"; return; }
  if(!imgBitmap){ document.getElementById('err').textContent="Choose an image first"; return; }

  // If no crop, use whole image on canvas; else crop that region
  let srcCanvas = document.createElement('canvas');
  if (crop.w && crop.h){
    const sx = Math.max(0, Math.min(crop.x, crop.x + crop.w));
    const sy = Math.max(0, Math.min(crop.y, crop.y + crop.h));
    const sw = Math.abs(crop.w);
    const sh = Math.abs(crop.h);

    srcCanvas.width = sw; srcCanvas.height = sh;
    srcCanvas.getContext('2d').drawImage(canvas, sx, sy, sw, sh, 0, 0, sw, sh);
  } else {
    srcCanvas.width = canvas.width; srcCanvas.height = canvas.height;
    srcCanvas.getContext('2d').drawImage(canvas, 0, 0);
  }

  try {
    const ldu = await runLDUOCR(srcCanvas, worker);
    if(!ldu || ldu.length<3){
      document.getElementById('err').textContent="No postal code found. Try a tighter crop / better light.";
      return;
    }
    document.getElementById('ldu').value = ldu;
    document.getElementById('status').textContent = "OCR detected LDU: " + ldu;
    document.getElementById('err').textContent = "";
  } catch(e){
    document.getElementById('err').textContent = "OCR failed: " + e.message;
  }
});

/* ========== IMAGE PICKERS (now open the editor) ========== */
function recognizeFile(file){
  // open editor instead of immediate OCR; user can crop then run
  openEditorFromFile(file);
}

document.getElementById('btnImage').addEventListener('click', ()=>{
  const i=document.createElement('input'); i.type='file'; i.accept='image/*';
  i.onchange=e=>{ if(e.target.files[0]) recognizeFile(e.target.files[0]); };
  i.click();
});

document.getElementById('btnCamera').addEventListener('click', ()=>{
  const i=document.createElement('input'); i.type='file'; i.accept='image/*'; i.capture='environment';
  i.onchange=e=>{ if(e.target.files[0]) recognizeFile(e.target.files[0]); };
  i.click();
});
</script>
</body>
</html>