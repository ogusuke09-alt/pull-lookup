<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Pull # Lookup — OCR App (Crop + Debug)</title>
<link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
<style>
  :root { color-scheme: dark; }
  body{margin:0;padding:16px;background:#0d1117;color:#e6edf3;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Inter,Helvetica,Arial,sans-serif}
  h1{font-size:22px;margin:0 0 12px}
  .card{border:1px solid #30363d;border-radius:12px;padding:14px;margin:12px auto;max-width:960px;background:#0d1117}
  .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
  input[type="text"]{flex:1;min-width:200px;padding:10px 12px;border-radius:10px;border:1px solid #30363d;background:#0b1320;color:#e6edf3;font-size:16px}
  button{background:#2f6feb;border:none;color:#fff;border-radius:12px;padding:10px 14px;font-size:16px}
  button:disabled{opacity:.5}
  .ok{color:#7ee787;font-weight:600}
  .err{color:#ff7b72}
  .muted{color:#8b949e}
  .result{border:1px solid #30363d;border-radius:10px;padding:12px;margin-top:10px}
  /* Preview + crop overlay */
  #previewWrap{position:relative;display:inline-block;max-width:100%}
  #preview{display:block;border:1px dashed #3b3f46;border-radius:8px;max-width:100%}
  #overlay{position:absolute;left:0;top:0;right:0;bottom:0;touch-action:none}
  #rect{position:absolute;border:3px dashed #58a6ff;border-radius:6px;box-shadow:0 0 0 9999px rgba(0,0,0,.25);display:none}
  details{margin-top:10px}
  pre{white-space:pre-wrap}
</style>
<!-- Tesseract global -->
<script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>
</head>
<body>
  <div class="card">
    <h1>Pull # Lookup — OCR App</h1>
    <div id="ocrState" class="muted">Tap “Init OCR” to load the engine.</div>
    <div class="row" style="margin-top:8px">
      <button id="btnInit">Init OCR</button>
      <button id="btnLoadSampleCsv">Load sample CSV</button>
      <input type="file" id="csvFile" accept=".csv" />
    </div>
    <div id="csvInfo" class="muted" style="margin-top:6px"></div>
    <div id="initErr" class="err" style="margin-top:6px"></div>
  </div>

  <div class="card">
    <h2 style="margin:0 0 8px">Step 2: Enter LDU or use OCR</h2>
    <div class="row">
      <input id="lduInput" type="text" placeholder="LDU (last 3)" maxlength="3" />
      <button id="btnSearch">Search</button>
    </div>

    <div class="row" style="margin-top:8px">
      <button id="btnCamera">Scan with Camera</button>
      <button id="btnChoose">Choose Image</button>
    </div>

    <p class="muted" style="margin:10px 0 8px">
      Tip: rotate to make the postal code horizontal, draw a box around it, then run OCR.
    </p>

    <div id="previewWrap">
      <canvas id="preview"></canvas>
      <div id="overlay">
        <div id="rect"></div>
      </div>
    </div>

    <div class="row" style="margin-top:10px">
      <button id="btnRotateL">↺ Rotate 90° Left</button>
      <button id="btnRotateR">↻ Rotate 90° Right</button>
    </div>
    <div class="row" style="margin-top:8px">
      <button id="btnOcr">Run OCR on Crop</button>
      <button id="btnResetCrop">Reset Crop</button>
      <button id="btnToggleDebug">Toggle Debug</button>
    </div>

    <div id="ocrMsg" class="muted" style="margin-top:8px"></div>
    <div id="searchResult" class="result" style="display:none"></div>

    <details id="dbg" style="display:none">
      <summary>Debug</summary>
      <pre id="debug"></pre>
      <pre id="raw"></pre>
    </details>
  </div>

<script>
/* ========= Globals ========= */
let worker = null;
let data = [];
let imgOrig = null;
let rotation = 0;           // 0, 90, 180, 270
let previewScale = 1;       // original -> preview scale

const preview = document.getElementById('preview');
const ctx = preview.getContext('2d', { willReadFrequently: true });
const overlay = document.getElementById('overlay');
const rectEl  = document.getElementById('rect');
const debugEl = document.getElementById('debug');
const rawEl   = document.getElementById('raw');

/* ========= Helpers ========= */
function log(s){ debugEl.textContent += s + "\n"; }
function setText(id, s){ const el=document.getElementById(id); if(el) el.textContent=s; }
function regexPostal(text){
  // Canadian postal code, tolerant to spaces/newlines; excludes D F I O Q U
  const re = /([ABCEGHJKLMNPRSTVXY]\s*\d\s*[ABCEGHJKLMNPRSTVWXYZ])\s*(\d\s*[ABCEGHJKLMNPRSTVWXYZ]\s*\d)/gi;
  return re.exec(text);
}
function toLDU(full){ return full.replace(/\s/g,'').slice(-3).toUpperCase(); }

/* ========= OCR Init with CDN failover ========= */
const CDNS = [
  { name:"jsDelivr", worker:"https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/worker.min.js",
                      core:  "https://cdn.jsdelivr.net/npm/tesseract.js-core@5/dist/tesseract-core.wasm.js" },
  { name:"unpkg",    worker:"https://unpkg.com/tesseract.js@5/dist/worker.min.js",
                      core:  "https://unpkg.com/tesseract.js-core@5/dist/tesseract-core.wasm.js" },
  { name:"cdnjs",    worker:"https://cdnjs.cloudflare.com/ajax/libs/tesseract.js/5.0.5/worker.min.js",
                      core:  "https://cdnjs.cloudflare.com/ajax/libs/tesseract.js-core/5.0.5/tesseract-core.wasm.js" }
];
async function pickCdn(){
  for(const c of CDNS){
    try{
      const [a,b]=await Promise.all([
        fetch(c.worker,{method:"HEAD",mode:"cors",cache:"no-store"}),
        fetch(c.core,  {method:"HEAD",mode:"cors",cache:"no-store"}),
      ]);
      if(a.ok && b.ok) return c;
    }catch(_){}
  }
  throw new Error("No CDN reachable for Tesseract.");
}
document.getElementById('btnInit').addEventListener('click', initOCR);
async function initOCR(){
  try{
    setText('initErr','');
    if(!window.Tesseract){ setText('initErr','Tesseract library not loaded — refresh the page.'); return; }
    setText('ocrState','Finding OCR CDN…');
    const cdn = await pickCdn();
    setText('ocrState',`Loading OCR engine from ${cdn.name}…`);
    await Promise.all([
      fetch(cdn.worker,{mode:'cors',cache:'reload'}).catch(()=>{}),
      fetch(cdn.core,{mode:'cors',cache:'reload'}).catch(()=>{})
    ]);
    worker = await Tesseract.createWorker("eng", 1, { workerPath: cdn.worker, corePath: cdn.core });
    setText('ocrState',''); document.getElementById('ocrState').innerHTML = "<span class='ok'>OCR ready ✅</span>";
  }catch(e){
    setText('ocrState','Error ❌'); setText('initErr',"Init failed: " + (e?.message||e));
  }
}

/* ========= CSV handling ========= */
document.getElementById('btnLoadSampleCsv').addEventListener('click', ()=>{
  data = [{Depot:"Whiterock",Route:"LC0008",Street:"16 Ave",Range:"1500-1598",LDU:"1C2",Pull:"7"}];
  setText('csvInfo',"Sample loaded (1 row). Try LDU 1C2.");
});
document.getElementById('csvFile').addEventListener('change', e=>{
  const f=e.target.files[0]; if(!f) return;
  const r=new FileReader();
  r.onload=ev=>{
    const lines = ev.target.result.split(/\r?\n/).filter(Boolean);
    const headers = lines[0].split(",");
    const idx = {
      Depot: headers.indexOf("Depot"),
      Route: headers.indexOf("Route"),
      Street:headers.indexOf("Street"),
      Range: headers.indexOf("Address Range"),
      LDU:   headers.indexOf("LDU"),
      Pull:  headers.indexOf("Pull #")
    };
    data = lines.slice(1).map(row=>{
      const c=row.split(",");
      return { Depot:c[idx.Depot], Route:c[idx.Route], Street:c[idx.Street],
               Range:c[idx.Range], LDU:(c[idx.LDU]||"").trim().toUpperCase(), Pull:c[idx.Pull] };
    }).filter(x=>x.Depot && x.LDU && x.Pull);
    setText('csvInfo',`CSV loaded (${data.length} rows)`);
  };
  r.readAsText(f);
});

/* ========= Search by LDU ========= */
document.getElementById('btnSearch').addEventListener('click', ()=>{
  const ldu = document.getElementById('lduInput').value.trim().toUpperCase();
  const hit = data.find(r=>r.LDU===ldu);
  const box = document.getElementById('searchResult');
  box.style.display="block";
  box.innerHTML = hit
    ? `${hit.Route} • ${hit.Street} ${hit.Range||''}<br>LDU ${hit.LDU}<br><strong>Pull # ${hit.Pull}</strong>`
    : "No match.";
});

/* ========= Image pick / load / rotate / fit ========= */
document.getElementById('btnChoose').addEventListener('click', ()=> pickImage(false));
document.getElementById('btnCamera').addEventListener('click', ()=> pickImage(true));

function pickImage(useCamera){
  const inp=document.createElement('input');
  inp.type='file'; inp.accept='image/*';
  if(useCamera) inp.capture='environment';
  inp.onchange=e=>{ if(e.target.files[0]) loadImageFile(e.target.files[0]); };
  inp.click();
}

function loadImageFile(file){
  const img=new Image();
  img.onload=()=>{ imgOrig=img; rotation=0; fitCanvas(); resetCrop(); };
  img.src=URL.createObjectURL(file);
}

function fitCanvas(){
  if(!imgOrig) return;
  const maxW = Math.min(960, window.innerWidth*0.92);
  const maxH = Math.max(320, window.innerHeight*0.48);
  // logical size after rotation
  const rW = (rotation%180)? imgOrig.height : imgOrig.width;
  const rH = (rotation%180)? imgOrig.width  : imgOrig.height;
  let scale = Math.min(maxW/rW, maxH/rH); if(scale>1) scale=1;

  preview.width  = Math.round(rW * scale);
  preview.height = Math.round(rH * scale);
  overlay.style.width  = preview.width + "px";
  overlay.style.height = preview.height + "px";

  ctx.save();
  ctx.clearRect(0,0,preview.width,preview.height);
  if(rotation%360===0){
    ctx.drawImage(imgOrig, 0, 0, preview.width, preview.height);
  }else{
    ctx.translate(preview.width/2, preview.height/2);
    ctx.rotate(rotation*Math.PI/180);
    const dw = scale * imgOrig.width;
    const dh = scale * imgOrig.height;
    ctx.drawImage(imgOrig, -dw/2, -dh/2, dw, dh);
  }
  ctx.restore();

  previewScale = scale;
}

document.getElementById('btnRotateL').addEventListener('click', ()=>{ if(imgOrig){ rotation=(rotation+270)%360; fitCanvas(); resetCrop(); }});
document.getElementById('btnRotateR').addEventListener('click', ()=>{ if(imgOrig){ rotation=(rotation+90)%360;  fitCanvas(); resetCrop(); }});

/* ========= Crop overlay (always visible & draggable) ========= */
let dragStart = null;          // pointer start (preview coords)
let rect = null;               // current crop rect {x,y,w,h} in preview coords

function resetCrop(){
  rect = null;
  rectEl.style.display='none';
}
function setRectEl(r){
  rectEl.style.left   = r.x+"px";
  rectEl.style.top    = r.y+"px";
  rectEl.style.width  = r.w+"px";
  rectEl.style.height = r.h+"px";
  rectEl.style.display='block';
}

function overlayPoint(e){
  const b = overlay.getBoundingClientRect();
  const x = (e.clientX ?? e.touches?.[0]?.clientX) - b.left;
  const y = (e.clientY ?? e.touches?.[0]?.clientY) - b.top;
  // clamp
  return { x: Math.max(0, Math.min(preview.width, x)),
           y: Math.max(0, Math.min(preview.height,y)) };
}

overlay.addEventListener('pointerdown', e=>{
  if(!preview.width) return;
  overlay.setPointerCapture(e.pointerId);
  const p = overlayPoint(e);
  dragStart = p;
  rect = {x:p.x, y:p.y, w:0, h:0};
  setRectEl(rect);
});
overlay.addEventListener('pointermove', e=>{
  if(!dragStart) return;
  const p = overlayPoint(e);
  const x0 = Math.min(dragStart.x, p.x);
  const y0 = Math.min(dragStart.y, p.y);
  const w  = Math.abs(p.x - dragStart.x);
  const h  = Math.abs(p.y - dragStart.y);
  rect = {x:x0,y:y0,w,h};
  setRectEl(rect);
});
overlay.addEventListener('pointerup',   ()=>{ dragStart=null; });
overlay.addEventListener('pointercancel',()=>{ dragStart=null; });

/* ========= OCR on crop (with proper coordinate mapping) ========= */
document.getElementById('btnOcr').addEventListener('click', runLduOCR);
async function runLduOCR(){
  try{
    if(!worker){ setText('ocrMsg',"Init OCR first."); return; }
    if(!imgOrig){ setText('ocrMsg',"Load or take a picture first."); return; }

    // If no crop, take a center band
    let r = rect;
    if(!r){
      const padY = Math.round(preview.height*0.08);
      r = { x: Math.round(preview.width*0.08), y: padY,
            w: Math.round(preview.width*0.84), h: Math.round(preview.height*0.25) };
      setRectEl(r);
      rect = r;
    }

    // Map preview -> original pixels (account for rotation)
    const sx = r.x / previewScale, sy = r.y / previewScale;
    const sw = r.w / previewScale, sh = r.h / previewScale;
    const W = imgOrig.width, H = imgOrig.height;
    let sx0, sy0, sw0, sh0;

    if(rotation%360===0){
      sx0=sx; sy0=sy; sw0=sw; sh0=sh;
    }else if(rotation%360===90){
      sx0 = sy;
      sy0 = W - (sx + sw);
      sw0 = sh; sh0 = sw;
    }else if(rotation%360===180){
      sx0 = W - (sx + sw);
      sy0 = H - (sy + sh);
      sw0 = sw; sh0 = sh;
    }else{ // 270
      sx0 = H - (sy + sh);
      sy0 = sx;
      sw0 = sh; sh0 = sw;
    }

    // clamp
    sx0 = Math.max(0, Math.min(W-1, sx0));
    sy0 = Math.max(0, Math.min(H-1, sy0));
    sw0 = Math.max(1, Math.min(W - sx0, sw0));
    sh0 = Math.max(1, Math.min(H - sy0, sh0));

    // Preprocess crop: upscale + grayscale + light threshold
    const off = document.createElement('canvas');
    const octx = off.getContext('2d');
    const scaleUp = Math.min(2.5, Math.max(1, 600 / Math.min(sw0, sh0)));
    off.width  = Math.round(sw0 * scaleUp);
    off.height = Math.round(sh0 * scaleUp);
    octx.imageSmoothingEnabled = true;
    octx.imageSmoothingQuality = 'high';
    octx.drawImage(imgOrig, sx0, sy0, sw0, sh0, 0, 0, off.width, off.height);

    const imgData = octx.getImageData(0,0,off.width,off.height);
    const d = imgData.data;
    for(let i=0;i<d.length;i+=4){
      const g = (d[i]*0.299 + d[i+1]*0.587 + d[i+2]*0.114);
      const v = g>160 ? 255 : (g<90 ? 0 : g);
      d[i]=d[i+1]=d[i+2]=v;
    }
    octx.putImageData(imgData,0,0);

    setText('ocrMsg',"Running OCR…");
    const res = await worker.recognize(off);
    const raw = (res?.data?.text || "").toUpperCase();
    rawEl.textContent = "RAW OCR:\n" + raw;

    const m = regexPostal(raw);
    if(!m){ setText('ocrMsg',"No postal code found — tighter crop / rotate level / better light."); return; }
    const ldu = toLDU(m[0]);
    document.getElementById('lduInput').value = ldu;
    setText('ocrMsg',"OCR detected LDU: " + ldu);
  }catch(e){
    setText('ocrMsg',"OCR failed: " + (e?.message||e));
  }
}

/* ========= Reset crop & toggle debug ========= */
document.getElementById('btnResetCrop').addEventListener('click', resetCrop);
document.getElementById('btnToggleDebug').addEventListener('click', ()=>{
  const d = document.getElementById('dbg');
  d.style.display = (d.style.display==='none' || !d.style.display) ? 'block' : 'none';
});
</script>
</body>
</html>